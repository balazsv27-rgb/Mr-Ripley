architecture3.md

Final conclusion (what we’re actually building)

We are not building a “Zapier+ChatGPT trading bot.”

We are building a Gold-first regime-adaptive decision engine with:

deterministic outputs

supervisor governance (veto constitution)

uncertainty/stress/drift/corr-break controls

vintage/as-of macro data discipline

friction-aware forward testing

Execution is optional, contract-based, and intentionally unwired until the decision math is frozen.

This aligns with your original M1 principle: structured events → scenarios → uncertainty, validated not by PnL alone. 

prompt

3) architecture3.md (FINAL)

# Gold Decision Engine — Architecture v3 (Final)

This document defines the final conceptual architecture for a **Gold-first decision engine**.
It is designed to be:

- **Regime-aware**
- **Drift-aware**
- **Correlation-break-aware**
- **Supervisor-governed**
- **Deterministic at the execution boundary**

Execution integration is **architecturally defined** but **intentionally not operationally wired**
until all numerical definitions, calibrations, and validation metrics are frozen.

---

# Core Philosophy

We are not building “an AI trading bot”.

We are designing:

> A regime-adaptive gold decision system with supervisory governance
> that produces deterministic execution contracts.

Key principle:

- **LLM (if used) is analyst/auditor**, not the brain.
- The brain is a **structured state machine + governed policy**.

---

# Layer 1 — Narrative Ingestion + Event Extractor (Event Layer)

**Purpose:** Convert narrative signals into structured, interpretable events relevant to gold.

## Inputs
- Curated RSS / institutional releases (Fed, BoE/ECB, macro releases, reputable finance sources)
- Optional: curated commodity/gold sources

## Components
- Feed Registry (source weighting, topic tags)
- RSS Adapter (fetch/parse/normalize)
- Content Enricher (snippet/evidence pointers)
- Event Extractor (rule-based + lightweight classifier)
- Event Normalizer (canonical ontology)
- Event Store (immutable evidence refs)

## Output Contract: `Event`
- event_id
- published_at / time_anchor
- source
- event_type
- actor
- direction
- magnitude (optional)
- confidence
- evidence_refs[]
- tags[]

This layer produces **structured narrative**, not trading decisions.

---

# Layer 2 — Market & Macro APIs (Truth Layer)

**Purpose:** Maintain authoritative numerical history + current state for gold and its macro drivers.

## Inputs
### Market
- Gold proxy price (XAUUSD / GC / GLD proxy as needed)
- OHLCV (at the chosen trading timeframe)
- Volatility proxies

### Macro
- Real yield proxies (e.g., TIPS yield series)
- USD proxies (e.g., DXY or suitable proxy)
- Policy/rates proxies (optional, but useful)
- Inflation proxies (optional)

## Mandatory Discipline: “Vintage / As-Of” Awareness
Macro data may be revised. Backtests must use **as-of** values available at that time.
If vintage is not available, the system must mark the feature with `revision_risk=true`
and penalize confidence accordingly.

## Components
- Ingestion Scheduler (backfill + incremental updates)
- API Connectors (market + macro)
- Time-Series Store (versioned observations)
- Feature Builder (standardized features, multi-horizon normalization)
- Data Freshness Tracker (feature age + decay)

## Output Contracts
### `MarketState(t)`
- trend_state
- volatility_state
- drawdown_state
- price_features

### `MacroState(t)`
- real_yield_state
- usd_state
- policy_state (optional)
- inflation_state (optional)
- freshness / revision metadata

### `FeatureVector x_t`
A standardized vector used by Layer 3.

---

# Layer 3 — Memory + Regime + Decision System (Memory Layer)

**Purpose:** Map current state + events to historical analogs, detect regime validity, and produce governed decisions.

Layer 3 is the “brain”.

## Inputs
- `Event` stream (Layer 1)
- `MarketState(t)`, `MacroState(t)`, `x_t` (Layer 2)

---

## 3.1 Analog Memory Engine (Historical Patterning)

### Components
- State Vector Store (historical x_t)
- Reaction Store (gold forward returns windows, drawdown/vol response)
- Similarity Search (kNN / distance metrics)
- Pattern Aggregator (distributions by regime/event conditioning)

### Output (analytical): `ScenarioResult`
- P(up/down)
- expected return
- percentile bands
- tail risk metrics
- top analog timestamps + distances
- explanation trace
- uncertainty metrics

This is an analytical product. Not execution-facing.

---

## 3.2 Regime Gate (Conditional World Model)

### Purpose
Prevent universal, static “real yield * -1” logic from becoming a time bomb.
Driver effects are **conditional on regime**.

### Regime Hierarchy
**Base regimes (always defined):**
- Normal
- Stress
- RegimeShift / Unknown

**Dynamic regimes (optional, data-driven):**
- Clusters detected when current state is far from known regimes.
- Must support “human labeling” workflow.

### Unknown Detection
Compute a **distance-to-known-regimes** score (e.g., centroid distance / kNN distance).
If persistently high → `UnknownMode=true`.

---




